{-# LANGUAGE DataKinds #-}
{-# LANGUAGE TypeOperators #-}

module Curve
       ( ModQ
       , ModL
       , Point(..)
       , basePoint
       , isOnCurve
       , isOnCurveSubgroup
       , (.+)
       , (.*)
       ) where

import qualified Data.Binary as Bin
import qualified Data.Binary.Get as BinG
import qualified Data.Binary.Put as BinP
import           Data.Bits
import           Data.Modular (ℤ, (/)())
import           Encoding (encodeInt256, decodeInt256)
import           GHC.TypeLits

-- Field of integers modulo Q.
type ModQ = ℤ/(2^255 - 19)

-- Field of integers modulo L.
-- The twisted edwards curve is defined as:
-- { (x, y) ∈ ModQ^2 | -x^2 + y^2 = 1 + d * x^2 * y^2 }
-- The points on the curve constitute a group.
-- The order of the curve group is CG=8*L.
-- L is the order of the curve subgroup generated by the base point.
-- I.e. the base point generates L points of the curve defined above.
-- The curve has a cofactor of 8, so the total number of points in the
-- curve defined above is 8*L.
type ModL = ℤ/(2^252 + 27742317777372353535851937790883648493)

-- Point is a point on the curve subgroup generated by basepoint.
data Point = Point ModQ ModQ
           deriving (Show, Eq)

instance Bin.Binary Point where
    put = BinP.putByteString . encodePoint
      where
        encodePoint (Point x y) =
            encodeInt256 $ if even (toInteger x)
                           then fromIntegral y
                           else fromIntegral y + 2^255

    get = decodePoint <$> BinG.getByteString 32
      where
        decodePoint bs = Point x' y'
          where
            y = decodeInt256 bs
            yb = y .&. (2^255) == 2^255
            y' = fromIntegral $ if yb then y - (2^255) else y
            x = curveXfromY y'
            x' = if odd (toInteger x) /= yb then -x else x
d :: ModQ
d = -121665 `div` 121666

-- Is the point on the curve group?
isOnCurve :: Point -> Bool
isOnCurve (Point x y) = -x*x + y*y == 1 + d*x*x*y*y

-- Is the point on the curve subgroup generated by basePoint?
-- Points of other subgroups have an order that is a divisor of 8,
-- so multiplying by 8 would yield zero in that case.
isOnCurveSubgroup :: Point -> Bool
isOnCurveSubgroup p = isOnCurve p && 8 .* p /= Point 0 1 && mul l p == Point 0 1
  where
    l = 2^252 + 27742317777372353535851937790883648493

curveXfromY :: ModQ -> ModQ
curveXfromY y = if odd x2 then x2 else -x2
  where
    xx = (y*y-1) `div` (d*y*y+1)
    x = xx ^ ((q+3) `div` 8)
    x2 = if (x*x - xx) == 0
         then x
         else x * ic
    ic = 2^((q-1) `div` 4)
    q = 2^255 - 19

basePoint :: Point
basePoint = Point x y
  where
    y = 4 `div` 5
    x = curveXfromY y

(.+) :: Point -> Point -> Point
Point x1 y1 .+ Point x2 y2 = Point x3 y3
  where
    f = d*x1*x2*y1*y2
    x3 = (x1*y2 + x2*y1) `div` (1+f)
    y3 = (y1*y2 + x1*x2) `div` (1-f)

-- scalar multiplication on the curve subgroup generated by basePoint.
(.*) :: ModL -> Point -> Point
e .* p = mul (toInteger e) p

-- scalar multiplication on the curve group.
mul :: Integer -> Point -> Point
mul e p = mul' e
  where
    mul' 0 = Point 0 1
    mul' e' = let pp = double $ mul' (e' `div` 2)
              in if even e' then pp else p .+ pp
    double point = point .+ point
